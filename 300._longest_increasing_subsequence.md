###300. Longest Increasing Subsequence

题目:
<https://leetcode.com/problems/longest-increasing-subsequence/>


难度:
Medium


CLRS 习题 15.4-5 

思路一：

继续利用 [longest common subsequence](https://github.com/KrisYu/LeetCode-CLRS-Python/blob/master/1143._Longest_Common_Subsequence.md)

把 nums sort，同时去重，然后找它和 nums 的 longest common subsequence：


```Python3
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def longestCommonSubsequence(nums1, nums2):
            """
            :type text1: str
            :type text2: str
            :rtype: int
            """
            m, n = len(nums1), len(nums2)

            c = [[0 for _ in range(n+1)] for _ in range(m+1)]
            for i in range(m):
                for j in range(n):
                    if nums1[i] == nums2[j]:
                        c[i+1][j+1] = c[i][j] + 1
                    elif c[i][j+1] >= c[i+1][j]:
                        c[i+1][j+1] = c[i][j+1]
                    else:
                        c[i+1][j+1] = c[i+1][j]
            return c[-1][-1]

        nums_sorted = list(set(nums))
        nums_sorted.sort()

        
        return longestCommonSubsequence(nums, nums_sorted)

```

无法 AC， 超时。

思路二：



递推关系式：

```
dp[i] = max(dp[j] + 1) if num[i] > num[j] 
dp[i] = 1 else
```

最后loop一圈，求出最长的 

AC 代码

```
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums: return 0
        n = len(nums)
        dp = [1 for i in range(n)]
        for i in range(1,n):
        	for j in range(i):
        		if nums[i] > nums[j] :
        			dp[i] = max(dp[i],dp[j] + 1)

        return max(dp)
```

思路三：


在 [wikipedia](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) 上能找到 O(nlogn) 的伪码，不过此处不再实现，o(╯□╰)o